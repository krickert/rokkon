package com.rokkon.pipeline.engine.setup;

import com.google.protobuf.Empty;
import com.google.protobuf.Struct;
import com.google.protobuf.Value;
import com.rokkon.pipeline.consul.test.ConsulTestResource;
import com.rokkon.pipeline.engine.test.DummyProcessorService;
import com.rokkon.search.model.PipeDoc;
import com.rokkon.search.sdk.*;
import io.grpc.health.v1.HealthCheckRequest;
import io.grpc.health.v1.HealthCheckResponse;
import io.grpc.health.v1.HealthGrpc;
import io.grpc.stub.StreamObserver;
import io.quarkus.test.common.QuarkusTestResource;
import io.quarkus.test.junit.QuarkusTest;
import io.restassured.RestAssured;
import org.junit.jupiter.api.*;
import org.jboss.logging.Logger;

import jakarta.inject.Inject;
import java.io.IOException;
import java.time.Duration;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.hamcrest.Matchers.*;

/**
 * Comprehensive test demonstrating RokkonSetupHelper usage with assertions.
 * Tests the full flow from cluster creation to module processing.
 */
@QuarkusTest
@QuarkusTestResource(ConsulTestResource.class)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
public class RokkonSetupHelperTest {
    
    private static final Logger LOG = Logger.getLogger(RokkonSetupHelperTest.class);
    
    @Inject
    RokkonSetupHelper setupHelper;
    
    private static RokkonSetupHelper.SetupContext setupContext;
    
    @Test
    @Order(1)
    @DisplayName("RokkonSetupHelper should create cluster, start gRPC server, and register module")
    void testCompleteSetupFlow() {
        String clusterName = "test-cluster-" + UUID.randomUUID();
        String moduleName = "test-processor-" + UUID.randomUUID();
        
        // Build the complete setup
        setupContext = RokkonSetupHelper.builder()
                .withHttpEndpoint("localhost", RestAssured.port)
                .createCluster(clusterName, Map.of(
                    "environment", "test",
                    "version", "1.0.0"
                ))
                .withHealthCheck()
                .startGrpcServer(new DummyProcessorService())
                .withModuleMetadata("capability", "test-processing")
                .registerModule(moduleName)
                .build();
        
        // Verify setup context
        assertThat(setupContext).isNotNull();
        assertThat(setupContext.clusterName).isEqualTo(clusterName);
        assertThat(setupContext.moduleName).isEqualTo(moduleName);
        assertThat(setupContext.grpcPort).isGreaterThan(0);
        assertThat(setupContext.grpcServer).isNotNull();
        assertThat(setupContext.grpcServer.isShutdown()).isFalse();
        assertThat(setupContext.healthManager).isNotNull();
        
        // Verify setup tracking
        assertThat(setupContext.completedSteps)
                .containsExactly("create-cluster", "start-grpc", "register-module");
        assertThat(setupContext.setupDuration).isNotNull();
        assertThat(setupContext.setupDuration.toMillis()).isGreaterThan(0);
        assertThat(setupContext.failedStep).isNull();
        assertThat(setupContext.setupError).isNull();
        
        // Verify summary
        Map<String, Object> summary = setupContext.getSummary();
        assertThat(summary).containsKeys("clusterName", "grpcPort", "moduleName", "setupDuration", "completedSteps");
        assertThat(summary.get("failed")).isEqualTo(false);
        
        LOG.infof("Setup completed: %s", summary);
    }
    
    @Test
    @Order(2)
    @DisplayName("Created cluster should be accessible via REST API")
    void testClusterCreation() {
        assertThat(setupContext).isNotNull();
        assertThat(setupContext.clusterName).isNotNull();
        
        // Verify cluster exists via REST API
        RestAssured.given()
            .when()
            .get("/clusters/{name}", setupContext.clusterName)
            .then()
            .statusCode(200)
            .body("name", equalTo(setupContext.clusterName))
            .body("metadata.created_by", equalTo("RokkonSetupHelper"))
            .body("metadata.environment", equalTo("test"))
            .body("metadata.version", equalTo("1.0.0"));
    }
    
    @Test
    @Order(3)
    @DisplayName("gRPC health check should report serving status")
    void testHealthCheck() {
        assertThat(setupContext).isNotNull();
        assertThat(setupContext.grpcChannel).isNotNull();
        
        // Create health check stub
        HealthGrpc.HealthBlockingStub healthStub = HealthGrpc.newBlockingStub(setupContext.grpcChannel);
        
        // Check overall health
        HealthCheckRequest request = HealthCheckRequest.newBuilder()
                .setService("") // Empty string checks overall health
                .build();
        
        HealthCheckResponse response = healthStub.check(request);
        
        assertThat(response).isNotNull();
        assertThat(response.getStatus()).isEqualTo(HealthCheckResponse.ServingStatus.SERVING);
    }
    
    @Test
    @Order(4)
    @DisplayName("Dummy processor should process documents successfully")
    void testProcessorFunctionality() throws InterruptedException {
        assertThat(setupContext).isNotNull();
        assertThat(setupContext.grpcChannel).isNotNull();
        
        // Create processor stub
        PipeStepProcessorGrpc.PipeStepProcessorStub stub = 
                PipeStepProcessorGrpc.newStub(setupContext.grpcChannel);
        
        // Create test document
        Struct metadata = Struct.newBuilder()
                .putFields("source", Value.newBuilder().setStringValue("RokkonSetupHelperTest").build())
                .putFields("test_run", Value.newBuilder().setStringValue(UUID.randomUUID().toString()).build())
                .build();
        
        PipeDoc pipeDoc = PipeDoc.newBuilder()
                .setId("test-doc-" + UUID.randomUUID())
                .setTitle("Test Document from RokkonSetupHelper")
                .setBody("This document tests the processor functionality")
                .setCustomData(metadata)
                .build();
        
        ProcessRequest request = ProcessRequest.newBuilder()
                .setDocument(pipeDoc)
                .build();
        
        // Process document
        CountDownLatch latch = new CountDownLatch(1);
        final ProcessResponse[] responseHolder = new ProcessResponse[1];
        final Throwable[] errorHolder = new Throwable[1];
        
        stub.processData(request, new StreamObserver<ProcessResponse>() {
            @Override
            public void onNext(ProcessResponse response) {
                responseHolder[0] = response;
            }
            
            @Override
            public void onError(Throwable t) {
                errorHolder[0] = t;
                latch.countDown();
            }
            
            @Override
            public void onCompleted() {
                latch.countDown();
            }
        });
        
        // Wait for response
        assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();
        assertThat(errorHolder[0]).isNull();
        
        ProcessResponse response = responseHolder[0];
        assertThat(response).isNotNull();
        assertThat(response.getSuccess()).isTrue();
        assertThat(response.hasOutputDoc()).isTrue();
        assertThat(response.getOutputDoc().getId()).isEqualTo(pipeDoc.getId());
        assertThat(response.getOutputDoc().hasCustomData()).isTrue();
        Struct customData = response.getOutputDoc().getCustomData();
        assertThat(customData.getFieldsMap())
                .containsKey("processed_by")
                .containsKey("processing_timestamp")
                .containsKey("source"); // Original metadata should still be there
        assertThat(customData.getFieldsOrThrow("processed_by").getStringValue()).isEqualTo("test-processor");
        assertThat(response.getProcessorLogsList())
                .contains("DummyProcessor: Processing document")
                .contains("DummyProcessor: Added metadata to document");
    }
    
    @Test
    @Order(5)
    @DisplayName("Module registration should be reflected in Consul")
    void testModuleRegistration() {
        assertThat(setupContext).isNotNull();
        assertThat(setupContext.moduleName).isNotNull();
        
        // In a real implementation, we would check Consul directly
        // For now, we verify the registration was successful via the setup context
        assertThat(setupContext.completedSteps).contains("register-module");
        
        // We could also verify by trying to register the same module again
        // which should fail or indicate it already exists
    }
    
    @Test
    @Order(6)
    @DisplayName("Setup with schema registration should work")
    void testSetupWithSchema() {
        String clusterName = "schema-cluster-" + UUID.randomUUID();
        String moduleName = "schema-processor";
        
        // Create a processor with schema
        DummyProcessorService processorWithSchema = new DummyProcessorService() {
            @Override
            public void getServiceRegistration(Empty request,
                                               StreamObserver<ServiceRegistrationData> responseObserver) {
                ServiceRegistrationData registration = ServiceRegistrationData.newBuilder()
                        .setModuleName(moduleName)
                        .setJsonConfigSchema("""
                            {
                                "type": "object",
                                "properties": {
                                    "prefix": {
                                        "type": "string",
                                        "description": "Prefix to add to processed documents"
                                    },
                                    "maxRetries": {
                                        "type": "integer",
                                        "minimum": 0,
                                        "maximum": 10
                                    }
                                },
                                "required": ["prefix"]
                            }
                            """)
                        .build();
                
                responseObserver.onNext(registration);
                responseObserver.onCompleted();
            }
        };
        
        try (var schemaContext = RokkonSetupHelper.builder()
                .withHttpEndpoint("localhost", RestAssured.port)
                .createCluster(clusterName)
                .withHealthCheck()
                .startGrpcServer(processorWithSchema)
                .registerModule(moduleName)
                .build()) {
            
            // Verify schema registration
            PipeStepProcessorGrpc.PipeStepProcessorBlockingStub blockingStub = 
                    PipeStepProcessorGrpc.newBlockingStub(schemaContext.grpcChannel);
            
            ServiceRegistrationData registration = blockingStub.getServiceRegistration(Empty.getDefaultInstance());
            
            assertThat(registration).isNotNull();
            assertThat(registration.getModuleName()).isEqualTo(moduleName);
            assertThat(registration.hasJsonConfigSchema()).isTrue();
            assertThat(registration.getJsonConfigSchema()).contains("prefix", "maxRetries");
        }
    }
    
    @Test
    @Order(7)
    @DisplayName("Failed setup should clean up resources")
    void testFailedSetupCleanup() {
        // Try to create setup with invalid cluster name (simulate failure)
        assertThatThrownBy(() -> 
            RokkonSetupHelper.builder()
                .withHttpEndpoint("invalid-host", 99999)
                .withValidation(true)
                .withTimeout(Duration.ofSeconds(5))
                .createCluster("fail-cluster")
                .build()
        )
        .isInstanceOf(RokkonSetupHelper.SetupException.class)
        .hasMessageContaining("Setup failed");
        
        // Resources should be cleaned up automatically
    }
    
    @Test
    @Order(8)
    @DisplayName("Custom setup steps should be executed")
    void testCustomSetupSteps() {
        final boolean[] customStepExecuted = {false};
        
        try (var customContext = RokkonSetupHelper.builder()
                .withHttpEndpoint("localhost", RestAssured.port)
                .withCustomStep("custom-verification", () -> {
                    LOG.info("Executing custom verification step");
                    customStepExecuted[0] = true;
                })
                .createCluster("custom-cluster-" + UUID.randomUUID())
                .build()) {
            
            assertThat(customStepExecuted[0]).isTrue();
            assertThat(customContext.completedSteps).contains("custom-verification", "create-cluster");
        }
    }
    
    @Test
    @Order(9)
    @DisplayName("Injected builder should use CDI services")
    void testInjectedBuilder() {
        // When using the injected builder, it should have access to CDI services
        try (var injectedContext = setupHelper.injectedBuilder()
                .createCluster("injected-cluster-" + UUID.randomUUID())
                .withHealthCheck()
                .startGrpcServer(new DummyProcessorService())
                .registerModule("injected-module")
                .build()) {
            
            assertThat(injectedContext).isNotNull();
            assertThat(injectedContext.clusterName).startsWith("injected-cluster-");
            assertThat(injectedContext.grpcServer).isNotNull();
            assertThat(injectedContext.completedSteps)
                    .containsExactly("create-cluster", "start-grpc", "register-module");
        }
    }
    
    @AfterAll
    static void cleanup() {
        if (setupContext != null) {
            setupContext.cleanup();
            LOG.info("Main setup context cleaned up");
        }
    }
}