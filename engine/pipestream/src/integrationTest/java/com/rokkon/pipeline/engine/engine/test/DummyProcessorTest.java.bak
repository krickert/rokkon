package com.rokkon.pipeline.engine.test;

import com.google.protobuf.Empty;
import com.rokkon.pipeline.engine.api.ModuleRegistrationResource;
import com.rokkon.pipeline.engine.service.ModuleRegistrationService;
import com.google.protobuf.Struct;
import com.google.protobuf.Value;
import com.rokkon.search.model.PipeDoc;
import com.rokkon.search.sdk.*;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.health.v1.HealthCheckRequest;
import io.grpc.health.v1.HealthCheckResponse;
import io.grpc.health.v1.HealthGrpc;
import io.grpc.stub.StreamObserver;
import io.quarkus.grpc.GrpcClient;
import io.quarkus.test.junit.QuarkusTest;
import io.quarkus.test.junit.TestProfile;
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import org.junit.jupiter.api.*;
import org.jboss.logging.Logger;

import jakarta.inject.Inject;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;
import static org.hamcrest.Matchers.*;

/**
 * Comprehensive test that tests the full flow from cluster creation to dummy processor.
 * Tests are ordered to build upon each other, making them reusable as setups.
 */
@QuarkusTest
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
@TestProfile(DummyProcessorTestProfile.class)
public class DummyProcessorTest {
    
    private static final Logger LOG = Logger.getLogger(DummyProcessorTest.class);
    private static final String CLUSTER_NAME = "test-cluster-" + UUID.randomUUID();
    private static final int GRPC_PORT = 9000;
    
    @Inject
    ModuleRegistrationService registrationService;
    
    @GrpcClient("pipeStepProcessor")
    PipeStepProcessor pipeStepProcessor;
    
    private static ManagedChannel channel;
    private static PipeStepProcessorGrpc.PipeStepProcessorBlockingStub blockingStub;
    private static HealthGrpc.HealthBlockingStub healthStub;
    
    @BeforeAll
    static void setupChannel() {
        channel = ManagedChannelBuilder
                .forAddress("localhost", GRPC_PORT)
                .usePlaintext()
                .build();
        blockingStub = PipeStepProcessorGrpc.newBlockingStub(channel);
        healthStub = HealthGrpc.newBlockingStub(channel);
    }
    
    @AfterAll
    static void cleanupChannel() {
        if (channel != null) {
            channel.shutdown();
        }
    }
    
    @Test
    @Order(1)
    @DisplayName("Step 1: Engine should auto-create cluster on startup")
    void testClusterAutoCreation() {
        LOG.infof("Testing cluster auto-creation for cluster: %s", CLUSTER_NAME);
        
        // Engine should have already created the cluster on startup
        // We'll verify by checking the cluster endpoint
        RestAssured.given()
            .when()
            .get("/clusters/{name}", CLUSTER_NAME)
            .then()
            .statusCode(200)
            .body("name", equalTo(CLUSTER_NAME))
            .body("metadata.auto_created", equalTo("true"));
    }
    
    @Test
    @Order(2)
    @DisplayName("Step 2: Dummy processor should be accessible via gRPC")
    void testDummyProcessorConnection() {
        LOG.info("Testing dummy processor gRPC connection");
        
        // Test service registration endpoint
        ServiceRegistrationData registration = blockingStub.getServiceRegistration(Empty.getDefaultInstance());
        
        assertThat(registration).isNotNull();
        assertThat(registration.getModuleName()).isEqualTo("test-processor");
        assertThat(registration.hasJsonConfigSchema()).isFalse(); // First test without schema
    }
    
    @Test
    @Order(3)
    @DisplayName("Step 3: Dummy processor should process data without schema")
    void testProcessDataWithoutSchema() throws InterruptedException {
        LOG.info("Testing dummy processor data processing without schema");
        
        // Create a test document
        Struct metadata = Struct.newBuilder()
                .putFields("test_key", Value.newBuilder().setStringValue("test_value").build())
                .putFields("source", Value.newBuilder().setStringValue("DummyProcessorTest").build())
                .build();
        
        PipeDoc pipeDoc = PipeDoc.newBuilder()
                .setId("test-doc-1")
                .setTitle("Test Document")
                .setBody("This is a test document for processing")
                .setCustomData(metadata)
                .build();
        
        ProcessRequest request = ProcessRequest.newBuilder()
                .setDocument(pipeDoc)
                .build();
        
        // Use async stub with observer
        CountDownLatch latch = new CountDownLatch(1);
        final ProcessResponse[] responseHolder = new ProcessResponse[1];
        
        StreamObserver<ProcessResponse> responseObserver = new StreamObserver<ProcessResponse>() {
            @Override
            public void onNext(ProcessResponse response) {
                responseHolder[0] = response;
            }
            
            @Override
            public void onError(Throwable t) {
                LOG.errorf(t, "Error in processData call");
                latch.countDown();
            }
            
            @Override
            public void onCompleted() {
                latch.countDown();
            }
        };
        
        // Call the service
        PipeStepProcessorGrpc.newStub(channel).processData(request, responseObserver);
        
        // Wait for response
        assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();
        
        ProcessResponse response = responseHolder[0];
        assertThat(response).isNotNull();
        assertThat(response.getSuccess()).isTrue();
        assertThat(response.hasOutputDoc()).isTrue();
        // Check the custom_data was updated with processing info
        assertThat(response.getOutputDoc().hasCustomData()).isTrue();
        Struct customData = response.getOutputDoc().getCustomData();
        assertThat(customData.getFieldsMap())
                .containsKey("processed_by")
                .containsKey("processing_timestamp")
                .containsKey("test_key"); // Original data should still be there
        assertThat(customData.getFieldsOrThrow("processed_by").getStringValue()).isEqualTo("test-processor");
        assertThat(customData.getFieldsOrThrow("test_key").getStringValue()).isEqualTo("test_value");
        assertThat(response.getProcessorLogsList())
                .contains("DummyProcessor: Processing document")
                .contains("DummyProcessor: Added metadata to document");
    }
    
    @Test
    @Order(4)
    @DisplayName("Step 4: Health check should report healthy")
    void testHealthCheck() {
        LOG.info("Testing health check");
        
        HealthCheckRequest request = HealthCheckRequest.newBuilder()
                .setService("") // Empty string checks overall health
                .build();
        
        HealthCheckResponse response = healthStub.check(request);
        
        assertThat(response).isNotNull();
        assertThat(response.getStatus()).isEqualTo(HealthCheckResponse.ServingStatus.SERVING);
    }
    
    @Test
    @Order(5)
    @DisplayName("Step 5: Module registration should succeed")
    void testModuleRegistration() {
        LOG.info("Testing module registration via API");
        
        var registrationRequest = """
            {
                "moduleName": "test-processor",
                "host": "localhost",
                "port": %d,
                "clusterName": "%s",
                "serviceType": "PipeStepProcessor",
                "metadata": {
                    "version": "1.0.0",
                    "capabilities": ["process", "transform"]
                }
            }
            """.formatted(GRPC_PORT, CLUSTER_NAME);
        
        RestAssured.given()
            .contentType(ContentType.JSON)
            .body(registrationRequest)
            .when()
            .post("/modules/register")
            .then()
            .statusCode(200)
            .body("success", is(true))
            .body("moduleId", notNullValue())
            .body("message", containsString("registered successfully"));
    }
    
    @Test
    @Order(6)
    @DisplayName("Step 6: Update dummy processor to include schema")
    void testUpdateProcessorWithSchema() {
        LOG.info("Testing processor update with schema");
        
        // This would typically involve updating the processor configuration
        // For now, we'll just verify that the service can be reconfigured
        ServiceRegistrationData registration = blockingStub.getServiceRegistration(Empty.getDefaultInstance());
        
        assertThat(registration).isNotNull();
        assertThat(registration.getModuleName()).isEqualTo("test-processor");
        // In a real scenario, we'd update the processor and check for the schema
    }
    
    @Test
    @Order(7)
    @DisplayName("Step 7: Process data with schema validation")
    void testProcessDataWithSchema() throws InterruptedException {
        LOG.info("Testing dummy processor data processing with schema");
        
        // Create a test document with configuration
        Struct metadata = Struct.newBuilder()
                .putFields("test_key", Value.newBuilder().setStringValue("test_value").build())
                .putFields("config_test", Value.newBuilder().setStringValue("true").build())
                .build();
        
        PipeDoc pipeDoc = PipeDoc.newBuilder()
                .setId("test-doc-2")
                .setTitle("Test Document with Config")
                .setBody("This is a test document for processing with configuration")
                .setCustomData(metadata)
                .build();
        
        // Add configuration to the request
        ProcessConfiguration config = ProcessConfiguration.newBuilder()
                .putConfigParams("prefix", "PROCESSED")
                .build();
        
        ProcessRequest request = ProcessRequest.newBuilder()
                .setDocument(pipeDoc)
                .setConfig(config)
                .build();
        
        // Use async stub with observer
        CountDownLatch latch = new CountDownLatch(1);
        final ProcessResponse[] responseHolder = new ProcessResponse[1];
        
        StreamObserver<ProcessResponse> responseObserver = new StreamObserver<ProcessResponse>() {
            @Override
            public void onNext(ProcessResponse response) {
                responseHolder[0] = response;
            }
            
            @Override
            public void onError(Throwable t) {
                LOG.errorf(t, "Error in processData call");
                latch.countDown();
            }
            
            @Override
            public void onCompleted() {
                latch.countDown();
            }
        };
        
        // Call the service
        PipeStepProcessorGrpc.newStub(channel).processData(request, responseObserver);
        
        // Wait for response
        assertThat(latch.await(5, TimeUnit.SECONDS)).isTrue();
        
        ProcessResponse response = responseHolder[0];
        assertThat(response).isNotNull();
        assertThat(response.getSuccess()).isTrue();
        assertThat(response.hasOutputDoc()).isTrue();
        assertThat(response.getProcessorLogsList())
                .contains("DummyProcessor: Processing document");
    }
}