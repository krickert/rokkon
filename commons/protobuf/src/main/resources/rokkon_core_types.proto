syntax = "proto3";

package com.rokkon.search.model;

option java_multiple_files = true;
option java_package = "com.rokkon.search.model";
option java_outer_classname = "RokkonCoreTypesProto";

import "google/protobuf/timestamp.proto";
import "google/protobuf/struct.proto";

// --- Core Document Representation ---

// Information about a batch operation
message BatchInfo {
  // Unique identifier for this batch
  string batch_id = 1;

  // Total number of items in the batch
  int64 total_items = 2;

  // This item's position in the batch (1-based)
  int64 current_item_number = 3;

  // Human-readable name/description of the batch
  string batch_name = 4;

  // When this batch started processing
  google.protobuf.Timestamp started_at = 5;

  // Source of the batch (e.g., "pg_catalog.csv", "wikipedia-20240101.json")
  optional string source_reference = 6;
}

// Represents a single named vector embedding, typically for a whole document or a non-chunk segment.
message Embedding {
  // Optional: Name or identifier for the model that generated this embedding.
  optional string model_id = 1;
  repeated float vector = 2;        // The vector representation.
}

// Represents the text content and vector embedding for a single chunk.
message ChunkEmbedding {
  string text_content = 1;        // The actual text content of the chunk.
  repeated float vector = 2;       // The vector embedding for this chunk's text.
  optional string chunk_id = 3;     // Unique identifier for this chunk.
  optional int32 original_char_start_offset = 4; // Optional: start offset in original document.
  optional int32 original_char_end_offset = 5;   // Optional: end offset in original document.
  optional string chunk_group_id = 6; // Optional: Identifier for a group of related chunks.
  optional string chunk_config_id = 7; // Optional: Identifier for the chunking configuration used.
}

// Represents a single semantic chunk of text with its embedding.
message SemanticChunk {
  string chunk_id = 1;              // Unique identifier for this specific chunk within its parent SemanticProcessingResult.
  int64 chunk_number = 2;           // Sequential number of the chunk within its parent SemanticProcessingResult.
  ChunkEmbedding embedding_info = 3; // The text and embedding for this chunk.
  map<string, google.protobuf.Value> metadata = 4; // Optional metadata specific to this chunk (e.g., original page number, section).
}

// Represents the complete result of one specific semantic chunking and/or embedding process
// applied to a field of a PipeDoc. A PipeDoc can store multiple such results.
message SemanticProcessingResult {
  string result_id = 1;               // Unique ID for this specific result set (e.g., UUID for this instance of processing).
  string source_field_name = 2;       // Name of the field within the parent PipeDoc that was processed (e.g., "body", "title").

  string chunk_config_id = 3;         // Identifier for the chunking configuration used (e.g., "sentence_splitter_v1", "token_chunker_512_overlap_50").
  string embedding_config_id = 4;     // Identifier for the embedding model/configuration used (e.g., "ada_002_v1", "minilm_l6_v2").

  // A generated identifier/name for this set of (chunked and) embedded data.
  // Useful as a prefix for field names in a search index or for display/selection.
  // Example: "body_chunks_ada_002", "title_sentences_minilm"
  // This would typically be generated by the pipeline step that produces this result.
  optional string result_set_name = 5;

  repeated SemanticChunk chunks = 6;    // List of semantic chunks with their embeddings produced by this specific configuration.
  map<string, google.protobuf.Value> metadata = 7; // Metadata about this specific processing run (e.g., model version details, execution time).
}

message PipeDoc {
  string id = 1;                          // REQUIRED. Unique identifier for the document.
  optional string source_uri = 2;         // Optional. URI where the original document came from (e.g., s3://, http://).
  optional string source_mime_type = 3;   // Optional. Original MIME type of the content that *led* to this PipeDoc (e.g., "application/pdf").

  optional string title = 4;
  optional string body = 5;               // Main textual content, often the target for chunking/embedding.
  repeated string keywords = 6;
  optional string document_type = 7;      // e.g., "article", "product", "email".
  optional string revision_id = 8;        // Optional. Version identifier for the source content.

  optional google.protobuf.Timestamp creation_date = 9;   // When the source document was created or first seen.
  optional google.protobuf.Timestamp last_modified_date = 10; // When the source document content was last modified.
  optional google.protobuf.Timestamp processed_date = 11;   // When this PipeDoc representation was last significantly processed/updated by the pipeline.

  optional google.protobuf.Struct custom_data = 12; // For flexible, non-standard structured data related to the document.

  // Holds results from potentially multiple, different chunking and/or embedding processes applied to this document.
  repeated SemanticProcessingResult semantic_results = 13;

  // Map for storing other named embeddings (e.g., whole document embeddings, image embeddings).
  // Key could be a descriptive name like "full_document_ada_002_embedding" or "header_image_clip_embedding".
  map<string, Embedding> named_embeddings = 14;
  //binary data and associated metadata
  optional Blob blob = 15;
  //optional metadata
  map<string,string> metadata = 16;
}

// --- Binary Data Handling ---

message Blob {
  optional string blob_id = 1;            // Optional: Unique identifier for this blob (e.g., hash of content or UUID).
  bytes data = 2;                     // REQUIRED. The raw binary content.
  optional string mime_type = 3;        // MIME type of the content in 'data' (e.g., "application/pdf", "image/jpeg").
  optional string filename = 4;           // Optional: Original filename associated with this binary data.
  optional string encoding = 5;           // Optional: Character encoding if 'data' represents text (e.g., "UTF-8").
  map<string, string> metadata = 6;     // Optional: Additional key-value metadata specific to this blob.
}

// --- Error and History Structures ---

// Captures input state for a failed step attempt, used within ErrorData.
message FailedStepInputState {
  // The PipeDoc as it was *before* the failed step was attempted.
  optional PipeDoc doc_state = 1;
  // The Blob as it was *before* the failed step was attempted.
  optional Blob blob_state = 2;
  // The custom_json_config (as Struct) provided to the failed step.
  optional google.protobuf.Struct custom_config_struct = 3;
  // The config_params provided to the failed step.
  map<string, string> config_params = 4;
}

message ErrorData {
  string error_message = 1;               // REQUIRED. Human-readable description of the error.
  optional string error_code = 2;         // Optional. Machine-readable error code (e.g., "CONFIG_VALIDATION_ERROR", "TIMEOUT_ERROR").
  optional string technical_details = 3;    // Optional. Snippet of stack trace, detailed diagnostic information.
  string originating_step_name = 4;     // REQUIRED. The 'stepName' of the PipelineStepConfig where the error originated or was detected.
  optional string attempted_target_step_name = 5; // Optional. If error occurred during an attempt to route or dispatch to a *next* step.
  optional FailedStepInputState input_state_at_failure = 6; // Optional. State of data/config when the step failed, for reproducibility.
  google.protobuf.Timestamp timestamp = 7;  // REQUIRED. When the error occurred or was logged.
}

message StepExecutionRecord {
  int64 hop_number = 1;                       // Sequential hop number for this step in the stream.
  string step_name = 2;                        // 'stepName' of the PipelineStepConfig that was executed.
  optional string service_instance_id = 3;      // Optional. Identifier of the specific service instance/pod that executed the step.
  google.protobuf.Timestamp start_time = 4;     // When step processing began.
  google.protobuf.Timestamp end_time = 5;       // When step processing ended.
  // Expected statuses: "SUCCESS", "FAILURE", "SKIPPED" (add more as needed, e.g., "RETRYING")
  string status = 6;                           // REQUIRED. Outcome of the step.
  repeated string processor_logs = 7;           // Logs specifically from the processor for this step's execution.
  optional ErrorData error_info = 8;            // Specific error from *this step* if status is "FAILURE".
  optional string attempted_target_step_name = 9; // Optional. If status is "DISPATCH_FAILURE", this is the

}


enum ActionType {
  CREATE = 0;
  UPDATE = 1;
  DELETE = 2;
  NO_OP = 3;
}
// --- Pipeline Execution State ---

message PipeStream {
  string stream_id = 1;                       // REQUIRED. Unique ID for this execution flow instance.
  PipeDoc document = 2;                       // REQUIRED (can be an empty message initially). The primary document being processed.
  string current_pipeline_name = 3;           // REQUIRED. Name of the PipelineConfig being executed.

  // REQUIRED by the sender (Engine or Kafka Framework).
  // The 'stepName' (key from PipelineConfig.steps map) of the PipelineStepConfig
  // that is the intended next recipient/processor of this PipeStream.
  string target_step_name = 4;

  int64 current_hop_number = 5;               // For logging/tracing; incremented by the engine/framework *before* dispatching to
  // target_step_name.
  repeated StepExecutionRecord history = 6;     // History of executed steps in this stream.
  optional ErrorData stream_error_data = 7;     // Holds the first critical error that puts the *entire stream* into a general error
  // state, possibly halting further processing unless handled by an error pipeline.
  map<string, string> context_params = 8;     // Optional. Key-value parameters for the entire run's context (e.g., tenant_id, user_id,
  // correlation_id).
  ActionType action_type = 9;                 // REQUIRED
}